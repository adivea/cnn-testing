---
title: "Cut out Images for CNN"
author: "Adela Sobotkova"
date: "11/18/2021 updated `r format(Sys.time(), '%B %d, %Y')`" 
output: 
  html_document:
    toc: true
    toc_float: true
    highlight: tango
    code_folding: hide
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Need better training data?

Let's filter the mounds to the large and visible ones, and prepare cutouts so they can be run through the model and see if the detection rate improves.
First I create the loop to produce squares/grids to use to cutout segments from the raster, then I need to figure out by what characteristics I best improve the model (e.g. get those large scrubby mounds from NE)
```{r mound-grids-polys}

radius <- 75
mounds$northing <- st_coordinates(mounds)[,2]
mounds$easting <- st_coordinates(mounds)[,1]


# define the plot edges based upon the plot radius. 

yPlus <- mounds$northing+radius
xPlus <- mounds$easting+radius
yMinus <- mounds$northing-radius
xMinus <- mounds$easting-radius

# calculate polygon coordinates for each plot centroid. 
square <- cbind(xMinus,yPlus,  # NW corner
	xPlus, yPlus,  # NE corner
	xPlus,yMinus,  # SE corner
	xMinus,yMinus, # SW corner
	xMinus,yPlus)  # NW corner again - close ploygon

# Extract the mound ID information
ID <- mounds$TRAP_Code

# create spatial polygons from coordinates with mapply
polys <- SpatialPolygons(mapply(function(poly, id) 
		{
	  xy <- matrix(poly, ncol=2, byrow=TRUE)
	  Polygons(list(Polygon(xy)), ID=id)
	  }, 
	split(square, row(square)), ID),
	proj4string=CRS(as.character("+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")))

plot(polys)


mnd_polys <- st_as_sf(polys)
plot(mnd_polys$geometry)
mnd_polys$geometry


# Convert to sf feature
polys_df <- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))
polys_df
mnd_polys <- st_as_sf(polys_df)
mnd_polys

# Add attributes
mnd_poly <- mnd_polys %>% 
  left_join(mounddata, by = c("id"="MoundID"))

# Write to shapefile
st_write(mnd_poly, "data/moundpolys140.shp",driver = 'ESRI Shapefile')


mnd_poly2 <- mnd_poly %>% 
  filter(Height>=2) 
```


### Write a loop

```{r loop-POC, eval=FALSE}
# Loop over a sample of largish mounds and cutout postage stamp rasters
randomID <- mnd_poly2$id%>% 
  sample(size = 25, replace = FALSE)
unique(randomID)

 # cutouts per sample number
for (i in randomID){
  new_clip <- crop(kaz, mnd_poly[mnd_poly$id ==i,])
  plotRGB(new_clip)
  writeRaster(new_clip, filename= paste0("data/",i,".tiff"), format = "GTiff", overwrite =TRUE)
}

# Works only if there is overlap with the raster! Nonoverlapping don't work so well:
mnd_poly[mnd_poly$id ==2006,]
i = 2006

# Check for overlap with the satellite image
```


```{r generate--slowly-stamps-that-overlap-raster, eval = FALSE}
# Check spatial overlapO
#https://gis.stackexchange.com/questions/34535/detect-whether-there-is-a-spatial-polygon-in-a-spatial-extent
# in <- intersect(e, extent(sp))
# if (isTRUE(in)) { in <- gIntersects(as(e, 'SpatialPolygons'), sp) }

library(rgeos)

for (i in randomID){
  lapply(poly, function(raster) {
    poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")
    ei <- as(extent(kaz), "SpatialPolygons")
    if (gContainsProperly(ei,poly)) {
      paste0(i," is fully within")
      new_clip <- crop(kaz, mnd_poly[mnd_poly$id ==i,])
      plotRGB(new_clip)
      writeRaster(new_clip, 
                  filename= paste0("data/",i,".tiff"), 
                  format = "GTiff", overwrite =TRUE)
  } else if (gIntersects(ei,poly)) {
    paste0(i," intersects")
  } else {
    paste0(i," is fully outside the raster")
  }
})
}

# This works, but stamps are pixellated. Higher resolution is needed

randomID
new_clip
```

