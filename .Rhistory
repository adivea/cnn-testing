libraries("rgdal", "gdalUtils", "raster")
mosaic_rasters(gdalfile=c(KAZEcropped,KAZWcropped),dst_dataset="KAZoriginal.tif",of="GTiff")
writeRaster(KAZEcropped, file="KazEcropped.tif", format="GTiff")
writeRaster(KAZWcropped, file="KazWcropped.tif", format="GTiff")
files <- c("KazEcropped.tif","KazWcropped.tif")
mosaic_rasters(gdalfile=files,dst_dataset="KAZoriginal.tif",of="GTiff")
KAZEcropped
KAZWcropped
gdalinfo("KAZoriginal.tif")
?mosaic()
KAZE
template <- raster(st_as_sf(extent))
proj4string(template) <- CRS('+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs')
setwd("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac")
getwd()
writeRaster(template, file="KAZoriginal.tif", format="GTiff")
files <- c("Kaz_E_fuse.tif",
"Kaz_W_fuse.tif")
getwd()
list.files()
mosaic_rasters(gdalfile=files,dst_dataset="KAZoriginal.tif",of="GTiff")
# Cropped files should be mosaiced with mosaic(r1,r2,fun = mean)
KAZcropped <- mosaic(KAZEcropped,KAZWcropped, fun = mean)
origin(KAZEcropped)
origin(KAZWcropped)
sessionInfo()
origin(KAZE)
origin(KAZW)
KAZE
KAZW
rasterOptions(tolerance = 0.1)
# Cropped files should be mosaiced with mosaic(r1,r2,fun = mean)
KAZcropped <- mosaic(KAZEcropped,KAZWcropped, fun = mean) # different origin error
# Cropped files should be mosaiced with mosaic(r1,r2,fun = mean)
KAZcropped <- merge(KAZEcropped,KAZWcropped, fun = mean) # different origin error
KAZEcropped
KAZWcropped
KAZEcropped
KAZWcropped
origin(KAZWcropped)
origin(KAZEcropped)
# Cropped files should be mosaiced with mosaic(r1,r2,fun = mean)
KAZcropped <- merge(KAZEcropped,KAZWcropped, tolerance = 0.2) # different origin error
origin(KAZE)
origin(KAZW)
plotRGB(kaz)
extentKaz <- extent(kaz)
plotRGB(kaz); plot(extent, border = "red", add = TRUE); plot(extentKaz, border = "green", add = TRUE)
template <- raster(st_as_sf(extentKaz)) # may need to change extent for the larger files and then crop down
# Uncropped files need to be mosaiced with larger extent and then cropped to mound extent following Teng-Keng
# # https://tengkengvang.com/2018/11/12/mosaic-or-merge-rasters-in-r/
template_kaz <- raster(st_as_sf(extentKaz))
# Uncropped files need to be mosaiced with larger extent and then cropped to mound extent following Teng-Keng
# # https://tengkengvang.com/2018/11/12/mosaic-or-merge-rasters-in-r/
template_kaz <- raster(extentKaz)
template <- raster(st_as_sf(extent)) # may need to change extent for the larger files and then crop down
getwd()
proj4string(template_kaz) <- CRS('+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs')
writeRaster(template_kaz, file="KAZoriginal.tif", format="GTiff")
files <- c("Kaz_E_fuse.tif",
"Kaz_W_fuse.tif")
mosaic_rasters(gdalfile=files,dst_dataset="KAZoriginal.tif",of="GTiff")
# files <- c("Kaz_E_fuse.tif",
#            "Kaz_W_fuse.tif") # maybe these are compromised??
files <- c("mul_Kaz_East_Clip.tif",
"mul_Kaz_West_Clip.tif")
# Uncropped files need to be mosaiced with larger extent and then cropped to mound extent following Teng-Keng
# # https://tengkengvang.com/2018/11/12/mosaic-or-merge-rasters-in-r/
template_kaz <- raster(extentKaz)
proj4string(template_kaz) <- CRS('+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs')
writeRaster(template_kaz, file="KAZoriginal.tif", format="GTiff")
# files <- c("Kaz_E_fuse.tif",
#            "Kaz_W_fuse.tif") # maybe these are compromised??
files <- c("mul_Kaz_East_Clip.tif",
"mul_Kaz_West_Clip.tif")
mosaic_rasters(gdalfile=files,dst_dataset="KAZoriginal.tif",of="GTiff")
KAZcropped <- mosaic(KAZEcropped,KAZWcropped, fun = mean) # different origin error
rasterOptions(tolerance = 1)
KAZcropped <- mosaic(KAZEcropped,KAZWcropped, fun = mean) # different origin error
KAZcropped <- merge(KAZEcropped,KAZWcropped,tolerance=1)
KAZcropped
plotRGB(KAZcropped)
plotRGB(KAZcropped, stretch = "hist")
# Check for overlap with the satellite image
plotRGB(kaz);plot(mnd_poly2m$geometry, borders = "white", add = TRUE)
plotRGB(kaz);plot(mnd_poly2m$geometry, borders = "white", add = TRUE)
# Check for overlap with the satellite image
plotRGB(kaz, stretch = "lin");plot(mnd_poly2m$geometry, borders = "white", add = TRUE)
# Check for overlap with the satellite image
plotRGB(kaz, stretch = "hist");plot(mnd_poly2m$geometry, col = "white", add = TRUE)
# Check for overlap with the satellite image
plotRGB(kaz, stretch = "lin");plot(mnd_poly2m$geometry, col = "white", add = TRUE)
randomID
new_clip
plotRGB(new_clip)
plotRGB(new_clip, stretch = "lin")
i
getwd()
writeRaster(KAZcropped, file="Kazcropped.tif", format="GTiff")
writeRaster(KAZEcropped, file="KazEcropped.tif", format="GTiff")
writeRaster(KAZWcropped, file="KazWcropped.tif", format="GTiff")
randomID
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
plotRGB(new_clip)
# writeRaster(new_clip,
#             filename= paste0("data/",i,".tiff"),
#             format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Validation and cropping in a loop
library(rgeos)
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
plotRGB(new_clip)
# writeRaster(new_clip,
#             filename= paste0("data/",i,".tiff"),
#             format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
getwd()
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("stamps/",i,".tiff"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("stamps/",i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0(i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac/stamps",i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Loop to check for polygon and raster overlap and to generate stamps
for (i in i){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac/stamps/",i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
# Loop to check for polygon and raster overlap and to generate stamps
for (i in randomID){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac/stamps/",i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
randomID
plotRGB(new_clip)
library(sf)
library(raster)
source("STAMPS_LoadLargeImg.R")
radius <- 75 #twice that is 150m per side of polygon
radius <- 125 #twice that is 250m per side of polygon
mounds$northing <- st_coordinates(mounds)[,2]
mounds$easting <- st_coordinates(mounds)[,1]
# define the plot edges based upon the plot radius.
yPlus <- mounds$northing+radius
xPlus <- mounds$easting+radius
yMinus <- mounds$northing-radius
xMinus <- mounds$easting-radius
# calculate polygon coordinates for each plot centroid.
square <- cbind(xMinus,yPlus,  # NW corner
xPlus, yPlus,  # NE corner
xPlus,yMinus,  # SE corner
xMinus,yMinus, # SW corner
xMinus,yPlus)  # NW corner again - close polygon
# Extract the mound ID information
ID <- mounds$TRAP_Code
# create spatial polygons (squares) from mound coordinates with mapply
polys <- SpatialPolygons(mapply(function(poly, id)
{
xy <- matrix(poly, ncol=2, byrow=TRUE)
Polygons(list(Polygon(xy)), ID=id)
},
split(square, row(square)), ID),
proj4string=CRS(as.character("+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")))
plot(polys)
mnd_polys <- st_as_sf(polys)
plot(mnd_polys$geometry)
mnd_polys$geometry
# Convert to sf feature
polys_df <- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))
polys_df
mnd_polys <- st_as_sf(polys_df)
mnd_polys
# Add attributes
mnd_poly <- mnd_polys %>%
left_join(mounddata, by = c("id"="MoundID"))
# Write to shapefile
st_write(mnd_poly, "outdata/moundpolys250.shp",driver = 'ESRI Shapefile')
plot(mnd_polys$geometry)
polys
st_as_sf(polys)
mounds <- st_read("../1_Teaching/cds-spatial/data/KAZ_mounds.shp")
mounddata <- read_csv("../1_Teaching/cds-spatial/data/KAZ_mdata.csv")
# filter the noticeable ones (2+ meters)
mounds <- mounds %>%
left_join(mounddata, by = c("TRAP_Code"="MoundID"))
# Bring in all the mounds
mounds <- st_read("../1_Teaching/cds-spatial/data/KAZ_mounds.shp")
library(sf)
library(raster)
source("STAMPS_LoadLargeImg.R")
radius <- 75 #twice that is 150m per side of polygon
radius <- 125 #twice that is 250m per side of polygon
mounds$northing <- st_coordinates(mounds)[,2]
mounds$easting <- st_coordinates(mounds)[,1]
# define the plot edges based upon the plot radius.
yPlus <- mounds$northing+radius
xPlus <- mounds$easting+radius
yMinus <- mounds$northing-radius
xMinus <- mounds$easting-radius
# calculate polygon coordinates for each plot centroid.
square <- cbind(xMinus,yPlus,  # NW corner
xPlus, yPlus,  # NE corner
xPlus,yMinus,  # SE corner
xMinus,yMinus, # SW corner
xMinus,yPlus)  # NW corner again - clo
ID <- mounds$TRAP_Code
# create spatial polygons (squares) from mound coordinates with mapply
polys <- SpatialPolygons(mapply(function(poly, id)
{
xy <- matrix(poly, ncol=2, byrow=TRUE)
Polygons(list(Polygon(xy)), ID=id)
},
split(square, row(square)), ID),
proj4string=CRS(as.character("+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")))
plot(polys)
st_as_sf(polys)
polys_df <- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))
polys_df
mnd_poly <- st_as_sf(polys_df)
mnd_poly
# Add attributes
mnd_poly <- mnd_polys %>%
left_join(mounddata, by = c("id"="MoundID"))
# Add attributes
mnd_poly <- mnd_poly %>%
left_join(mounddata, by = c("id"="MoundID"))
# Write to shapefile
st_write(mnd_poly, "output_data/moundpolys250.shp",driver = 'ESRI Shapefile')
mnd_poly2m <- mnd_poly %>%
filter(Height>=2)
plot(mnd_poly2m$geometry);
plot(mnd_poly2m$geometry, col = "red", add = TRUE)
plot(mnd_poly$geometry);
plot(mnd_poly2m$geometry, col = "red", add = TRUE)
plot(mnd_poly$geometry)
plot(mnd_poly$geometry);
plot(mnd_poly2m$geometry, col = "red", add = TRUE)
plot(mnd_poly$geometry, main = "Mounds (black) and 2m+ mounds (red)");
plot(mnd_poly2m$geometry, col = "red", add = TRUE)
# Read in all remotely-sensed features
rs <- st_read("~/Desktop/TRAP_Oxbow/KAZ/RS_Points12.shp")
# Filter for the confirmed mounds and see breakdown of Type
rs %>%
filter(F_ACaus == "MND") %>% # we filter for actual mounds
group_by(F_Type) %>%
count()  # code VIS denotes 152 "visible on surface" mounds
# Look at the confirmed mounds labelled as 'visible on surface'
library(mapview)
rs %>%
filter(F_ACaus == "MND" & F_Type == "VIS") %>%
mapview()
visible_mounds <- rs %>%
filter(F_ACaus == "MND" & F_Type == "VIS")
mounds %>%
filter(Height>=3) %>%  # 185 are 2+ m high, 179 are 3+, 147 are 3.5+, 143 are 4+m
filter(TRAP_Code %in% visible_mounds$TRAP_code) %>%  #72 2.5 features, or 68 3m features, or 56 3.5 features caught
mapview()
visiblemounds3_5 <- mounds %>%
# 185 are 2+ m high, 179 are 3+, 147 are 3.5+, 143 are 4+m
filter(Height>=3.5) %>%
# 72 2.5 features, or 68 3m features, or 56 3.5 features caught
filter(TRAP_Code %in% visible_mounds$TRAP_code)
visiblemounds3_5$TRAP_Code
is.na(extract(KAZcropped[[1]],visiblemounds3_5))
####################################### LOAD SMALL KAZ IKONOS
kaz <-brick("../1_Teaching/cds-spatial/data/Kaz.tif")
# Remove interim files
remove(c(polys,polys_df, square))
# Remove interim files
remove(polys,polys_df, square)
library(sf)
library(raster)
source("STAMPS_LoadLargeImg.R")
radius <- 75 #twice that is 150m per side of polygon
radius <- 125 #twice that is 250m per side of polygon
mounds$northing <- st_coordinates(mounds)[,2]
mounds$easting <- st_coordinates(mounds)[,1]
# define the plot edges based upon the plot radius.
yPlus <- mounds$northing+radius
xPlus <- mounds$easting+radius
yMinus <- mounds$northing-radius
xMinus <- mounds$easting-radius
# calculate polygon coordinates for each plot centroid.
square <- cbind(xMinus,yPlus,  # NW corner
xPlus, yPlus,  # NE corner
xPlus,yMinus,  # SE corner
xMinus,yMinus, # SW corner
xMinus,yPlus)  # NW corner again - close polygon
# Extract the mound ID information
ID <- mounds$TRAP_Code
# create spatial polygons (squares) from mound coordinates with mapply
polys <- SpatialPolygons(mapply(function(poly, id)
{
xy <- matrix(poly, ncol=2, byrow=TRUE)
Polygons(list(Polygon(xy)), ID=id)
},
split(square, row(square)), ID),
proj4string=CRS(as.character("+proj=utm +zone=35 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0")))
plot(polys)
# Convert to sf feature via a SpatialDataframe (to preserve mound IDs)
polys_df <- SpatialPolygonsDataFrame(polys, data.frame(id=ID, row.names=ID))
polys_df
mnd_poly <- st_as_sf(polys_df)
mnd_poly
# Add attributes
mnd_poly <- mnd_poly %>%
left_join(mounddata, by = c("id"="MoundID"))
# Write to shapefile
st_write(mnd_poly, "output_data/moundpolys250.shp",driver = 'ESRI Shapefile')
# Write to shapefile
st_write(mnd_poly, "output_data/moundpolys250.shp",driver = 'ESRI Shapefile', overwrite = TRUE)
# Write to shapefile
st_write(mnd_poly, "output_data/moundpolys250.shp",driver = 'ESRI Shapefile', append=FALSE)
# Remove interim files
remove(polys,polys_df, square)
# Look at the polygons
mnd_poly2m <- mnd_poly %>%
filter(Height>=2)
plot(mnd_poly$geometry, main = "All mounds (black) and 2m+ mounds (red)");
plot(mnd_poly2m$geometry, col = "red", add = TRUE)
# Read in all remotely-sensed features
rs <- st_read("~/Desktop/TRAP_Oxbow/KAZ/RS_Points12.shp")
# Filter for the confirmed mounds and see breakdown of Type
rs %>%
filter(F_ACaus == "MND") %>% # we filter for actual mounds
group_by(F_Type) %>%
count()  # code VIS denotes 152 "visible on surface" mounds
# Look at the confirmed mounds labelled as 'visible on surface'
library(mapview)
rs %>%
filter(F_ACaus == "MND" & F_Type == "VIS") %>%
mapview()
visible_mounds <- rs %>%
filter(F_ACaus == "MND" & F_Type == "VIS")
mounds %>%
filter(Height>=3) %>%  # 185 are 2+ m high, 179 are 3+, 147 are 3.5+, 143 are 4+m
filter(TRAP_Code %in% visible_mounds$TRAP_code) %>%  #72 2.5 features, or 68 3m features, or 56 3.5 features caught
mapview()
visiblemounds3_5 <- mounds %>%
# 185 are 2+ m high, 179 are 3+, 147 are 3.5+, 143 are 4+m
filter(Height>=3.5) %>%
# 72 2.5 features, or 68 3m features, or 56 3.5 features caught
filter(TRAP_Code %in% visible_mounds$TRAP_code)
visiblemounds3_5$TRAP_Code
# Loop over a sample of largish mounds and cutout postage stamp rasters
randomID <- mnd_poly2$id%>%
sample(size = 25, replace = FALSE)
# Loop over a sample of largish mounds and cutout postage stamp rasters
randomID <- mnd_poly2m$id%>%
sample(size = 25, replace = FALSE)
unique(randomID)
# Better: Loop over visible 3.5m high mound IDs
randomID <- visiblemounds3_5$TRAP_Code
# Create a directory for stamps
dir.create("smallstamps")
# Create cutouts per sample number
for (i in randomID){
new_clip <- crop(kaz, mnd_poly[mnd_poly$id ==i,])
plotRGB(new_clip)
writeRaster(new_clip, filename= paste0("smallstamps/",i,".tiff"), format = "GTiff", overwrite =TRUE)
}
plotRGB(new_clip, stretch = "lin")
# If large raster is not in memory
# setwd("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac")
# KAZcropped <- brick("Kazcropped.tif")
# Alternatively if a rebuild is needed, run
#source("MOSAIC.R")
# Loop to check for polygon and raster overlap and to generate stamps
for (i in randomID){
lapply(poly, function(raster) {
poly <- as(mnd_poly[mnd_poly$id ==i,], "Spatial")    # convert polygon to 'Spatial' format
ei <- as(extent(KAZcropped), "SpatialPolygons")             # create an extent of sat img as 'Spatial' format
if (gContainsProperly(ei,poly)) {
paste0("Polygon for ", i," is fully within raster")
new_clip <- crop(KAZcropped, mnd_poly[mnd_poly$id ==i,])  # create the cutout
#plotRGB(new_clip)
writeRaster(new_clip,
filename= paste0("stamps/",i,".tif"),
# filename= paste0("E:/TRAP Workstation/Shared GIS/Satellite imagery/IKONOS/Kazanlak/ERDAS/Cormac/stamps/",i,".tif"),
format = "GTiff", overwrite =TRUE)
} else if (gIntersects(ei,poly)) {
paste0(i," intersects")
} else {
paste0(i," is fully outside the raster")
}
})
}
plotRGB(new_clip)
